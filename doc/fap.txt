* The Slasti Forum Access Protocol: Slasti-FAP *

= overview

The Forum is split into stateless and ephemeral front-ends (that usually
run in the context of webserver), and the service daemon that contains the
state. The front-ends and the daemon communicate over the Slasti-FAP
protocol (or simply FAP - when it is unambiguous in context).

Peers in FAP exchange messages, encoded in JSON. Messages are framed
using a simple run-length header in the following format:

byte 0:     unused for now
byte 1,2,3: length in network order

= authentication

Users of the forum are authenticated by the front-ends, but the access
to FAP service is authenticated separately, with front-ends themselves
being the principals. This is similar to how the usual webapps, such as
WordPress, authenticate to a MySQL database.

This design has two major flaws:
 - A security flaw in one front-end may open access to data of all users
   without a problem in FAP service.
 - It is impossible for end-users to access the FAP service securely without
   a front-end, no matter how sophisticated the client.

Also, some server operations require knowing the front user (see Type 11).
If authenticated principal is not the user, the user must be transmitted
in request argument.

Therefore, this decision is TBD. But for now, FAP aims to support
authenticating users against a FAP service as if it were Kerberos.

= messages

Type 0, server greeting, server to client:

{ "type":0,
  "challenge":"Y2hhbGxlbmdl" }

The challenge is a string of bytes, encoded with base64. The Type 0 is the
first message transmitted by the server after a connection is accepted.

Type 1, login, client to server:

{ "type":1,
  "hash":"sha256",
  "user":"aniforum",
  "login":"a640dda517d163fda7096521120cebe2da01af126b3df06eff11a6deb95e8392" }

The login string is the challenge concatenated with the shared secret,
then hashed, encoded in hex. Expected reply is either Type 2 ack or an error
(likely Type 3).

Type 2, ack, server to client:

{ "type":2 }

Type 3, nak, server to client:

{ "type":3,
  "error":"not logged in" }

Error strings are not localized.

Type 4, create section, client to server:

{ "type":4,
  "bundle":"main",
  "name":"/shaft",
  "title":"Everything SHAFT",
  "desc":"Updates and discussions of studio SHAFT and Akayuki Shinbo" }

Bundle is a presentation marker, to help group forums together, as done
by meta-forums of vBulletin and phpBB. Bundles are not like directories
or buckets, in that they do not contain sections, but merely tag them.
Bundle is optional, for small forums like VIP-89. If bundle is not set,
it is unherited from the section's parent, or root. It may be none.

The name has to start with a slash, just because, even on servers that
do not support recursive sections.

The Type 4 message is replied with Type 2 ack or Type 3 nak.

Type 5, quit, client to server:

{ "type":5 }

This is the only client message that receives no reply from the server.
Instead, the server closes the communication channel.

In protocols layered over TCP/IP, the explicit quit is vital when messages
and their actions are not idempotent (such as the case of SMTP). Without
an explicit quit, server cannot be certain that the client received the
last reply (in SMTP this would cause e-mail messages to replicate). In
FAP, this may cause problems when posting. In the end we would just end
with front-ends stuffing the connection with idempotent messages after
every post... which they do anyway, so it's not like we really need this.
However, we specify the explicit quit just in case.

Type 6, new message, client to server:

{ "type":6,
  "section":"/shaft",
  "thread":"515",
  "name":"a4943458",
  "body":"As if anyone needed any further proof." }

The section, thread, and name are respective keys.

Type 7, new thread, client to server:

{ "type":7,
  "section":"/shaft",
  "name":   "515",
  "subject":"Shinbo lost it" }

The "thread" field is an key in an index, usually not descriptive.

We may allow to use the same message in order to edit the subject of
an existing thread. Haven't decided yet.

It is not allowed to omit the section. Sectionless forums are configured
with one section, with the front-ends hiding it.

Type 8, list sections, client to server:

{ "type":8 }

We do not offer selectors here, such as listing by bundle.

Type 9, section list, server to client:

{ "type":9,
  [
    { "name":"/shaft",
      "bundle":"main",
      "name":"/shaft",
      "title":"Everything SHAFT",
      "desc":"Updates and discussions of studio SHAFT and Akayuki Shinbo" }
  ]
}

The Type 9 message is returned in reply to Type 8.

All sections are returned in one list. There should not be more than
a handful of them.

Type 10, list threads, client to server:

{ "type":10,
  "section": "/shaft",
  "mark":"515",
  "limit":50
  "user" :"wah" }

The Type 10 message requests a list of threads, starting with "mark",
up to "limit" numer of threads in length.

Threads are assumed to be sorted by the time they were updated,
from newest to oldest. There is no parameter to set the sort order.

If the "mark" parameter is omitted, listing beings from the thread
that was updated last. If "limit" is omitted, server assumes its
built-in maximum number.

The "user" parameter is name of front-end principal, used to generate
the unread status. This paramter is TBD, subject to overall authentication
scheme.

Type 11, thread list, server to client:

{ "type":11,
  "mark": "516",
  [
    { "name"   : "515",
      "subject": "Shinbo lost it",
      "unread" : 1 }
  ]
}

The return list may deliver a "mark" parameter, or the name where next
list request should start to continue the listing. If "mark" is missing,
assume that there are no more threads to list.

The list elements contain the usual "name" and "subject" attributes,
copied literally from Type 10 message. The "unread" attribute is the
number of unread messages for the user, if one was specified.
