* The Slasti Forum Access Protocol: Slasti-FAP *

= overview

The Forum is split into stateless and ephemeral front-ends (that usually
run in the context of webserver), and the service daemon that contains the
state. The front-ends and the daemon communicate over the Slasti-FAP
protocol (or simply FAP - when it is unambiguous in context).

Peers in FAP exchange messages, encoded in JSON. Messages are framed
using a simple run-length header in the following format:

byte 0:     unused for now
byte 1,2,3: length in network order

= authentication

Users of the forum are authenticated by the front-ends, but the access
to FAP service is authenticated separately, with front-ends themselves
being the principals. This is similar to how the usual webapps, such as
WordPress, authenticate to a MySQL database.

This design has two major flaws:
 - A security flaw in one front-end may open access to data of all users
   without a problem in FAP service.
 - It is impossible for end-users to access the FAP service securely without
   a front-end, no matter how sophisticated the client.

Therefore, this decision is TBD. But for now, FAP supports authenticating
users against a FAP service as if it were Kerberos.

= messages

Type 0, server greeting, server to client:

{ "type":0,
  "challenge":"Y2hhbGxlbmdl" }

The challenge is a string of bytes, encoded with base64. The Type 0 is the
first message transmitted by the server after a connection is accepted.

Type 1, login, client to server:

{ "type":1,
  "hash":"sha256",
  "user":"aniforum",
  "login":"a640dda517d163fda7096521120cebe2da01af126b3df06eff11a6deb95e8392" }

The login string is the challenge concatenated with the shared secret,
then hashed, encoded in hex. Expected reply is either Type 2 ack or an error
(likely Type 3).

Type 2, ack, server to client:

{ "type":2 }

Type 3, nak, server to client:

{ "type":3,
  "error":"not logged in" }

Error strings are not localized.

